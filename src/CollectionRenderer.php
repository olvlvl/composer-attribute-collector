<?php

namespace olvlvl\ComposerAttributeCollector;

/**
 * Renders collected attribute targets as PHP code.
 *
 * @internal
 */
final class CollectionRenderer
{
    public static function render(Collector $collector): string
    {
        $targetClassesCode = self::renderTargetClasses($collector->classes);
        $targetMethodsCode = self::renderTargetMethods($collector->methods);
        $targetPropertiesCode = self::renderTargetProperties($collector->properties);

        return <<<PHP
        <?php

        // attributes.php @generated by https://github.com/olvlvl/composer-attribute-collector

        namespace olvlvl\ComposerAttributeCollector;

        Attributes::with(fn () => new Collection(
            targetClasses: [
        $targetClassesCode
            ],
            targetMethods: [
        $targetMethodsCode
            ],
            targetProperties: [
        $targetPropertiesCode
            ],
        ));
        PHP;
    }

    /**
     * @param array<class-string, TargetClassRaw[]> $classes
     */
    private static function renderTargetClasses(array $classes): string
    {
        $code = '';

        foreach ($classes as $attribute => $targets) {
            $code .= "        \\$attribute::class => [\n";
            foreach ($targets as $target) {
                $argumentsCode = self::renderArguments($target->arguments);
                $code .= <<<PHP
                            [ $argumentsCode, \\$target->name::class ],

                PHP;
            }
            $code .= "        ],\n";
        }

        return $code;
    }

    /**
     * @param array<class-string, TargetPropertyRaw[]> $properties
     */
    private static function renderTargetProperties(array $properties): string
    {
        $code = '';

        foreach ($properties as $attribute => $targets) {
            $code .= "        \\$attribute::class => [\n";
            foreach ($targets as $target) {
                $argumentsCode = self::renderArguments($target->arguments);
                $code .= <<<PHP
                            [ $argumentsCode, \\$target->class::class, '$target->name' ],

                PHP;
            }
            $code .= "        ],\n";
        }

        return $code;
    }

    /**
     * @param array<class-string, TargetMethodRaw[]> $methods
     */
    private static function renderTargetMethods(array $methods): string
    {
        $code = '';

        foreach ($methods as $attribute => $targets) {
            $code .= "        \\$attribute::class => [\n";
            foreach ($targets as $target) {
                $argumentsCode = self::renderArguments($target->arguments);
                $code .= <<<PHP
                            [ $argumentsCode, \\$target->class::class, '$target->name' ],

                PHP;
            }
            $code .= "        ],\n";
        }

        return $code;
    }

    /**
     * @param mixed[] $array
     */
    public static function renderArguments(array $array): string
    {
        return var_export($array, true);
    }
}
